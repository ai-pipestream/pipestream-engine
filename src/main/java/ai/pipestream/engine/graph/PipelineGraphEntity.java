package ai.pipestream.engine.graph;

import ai.pipestream.config.v1.PipelineGraph;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.util.JsonFormat;
import io.quarkus.hibernate.reactive.panache.PanacheEntityBase;
import jakarta.persistence.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import org.jboss.logging.Logger;

import java.time.Instant;
import java.util.UUID;

/**
 * Entity representing a pipeline graph stored in PostgreSQL.
 * <p>
 * Stores complete graph snapshots as JSONB for efficient querying and flexible schema evolution.
 * The graph is stored as a JSON representation of the PipelineGraph protobuf message.
 * <p>
 * Design follows the snapshot-based storage model where each version is a complete,
 * self-contained graph definition. This enables fast activation and atomic rollbacks.
 * <p>
 * JSONB storage is ideal here because:
 * <ul>
 *   <li>Protobuf has built-in JSON serialization via JsonFormat</li>
 *   <li>Graphs are cached in memory, so serialization overhead is minimal</li>
 *   <li>PostgreSQL JSONB allows efficient querying of graph metadata</li>
 *   <li>Easy to serialize PipelineGraph proto to/from JSON</li>
 * </ul>
 *
 * @see ai.pipestream.config.v1.PipelineGraph
 */
@Entity
@Table(name = "pipeline_graphs", uniqueConstraints = {
    @UniqueConstraint(name = "uk_graph_id_version", columnNames = {"graph_id", "version"})
}, indexes = {
    @Index(name = "idx_graphs_active", columnList = "graph_id, is_active"),
    @Index(name = "idx_graphs_cluster", columnList = "cluster_id")
})
public class PipelineGraphEntity extends PanacheEntityBase {

    private static final Logger LOG = Logger.getLogger(PipelineGraphEntity.class);

    /** Primary key - UUID generated by database. */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", updatable = false, nullable = false)
    public UUID id;

    /** Logical graph identifier - multiple versions can exist for the same graph_id. */
    @Column(name = "graph_id", nullable = false, length = 255)
    public String graphId;

    /** Cluster this graph belongs to - used for multi-cluster deployments. */
    @Column(name = "cluster_id", nullable = false, length = 255)
    public String clusterId;

    /** Account identifier for multi-tenant isolation. */
    @Column(name = "account_id", nullable = false, length = 255)
    public String accountId;

    /** Version number - auto-incremented per graph_id for sequential versioning. */
    @Column(name = "version", nullable = false)
    public Long version;

    /** Complete PipelineGraph protobuf serialized as JSON and stored as JSONB. */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "graph_data", nullable = false, columnDefinition = "jsonb")
    public String graphData;

    /** Whether this version is currently active - only one active version per graph_id. */
    @Column(name = "is_active", nullable = false)
    public Boolean isActive = false;

    /** Timestamp when this graph version was created. */
    @Column(name = "created_at", nullable = false)
    public Instant createdAt;

    /** User or service that created this graph version. */
    @Column(name = "created_by", length = 255)
    public String createdBy;

    /**
     * Converts this entity to a PipelineGraph protobuf message.
     * <p>
     * Deserializes the JSONB graph_data field back into a PipelineGraph proto.
     *
     * @return The deserialized PipelineGraph
     * @throws RuntimeException if JSON deserialization fails
     */
    public PipelineGraph toProto() {
        try {
            PipelineGraph.Builder builder = PipelineGraph.newBuilder();
            JsonFormat.parser().merge(graphData, builder);
            return builder.build();
        } catch (InvalidProtocolBufferException e) {
            LOG.errorf(e, "Failed to deserialize PipelineGraph from JSON for graph_id=%s version=%d", graphId, version);
            throw new RuntimeException("Failed to deserialize PipelineGraph", e);
        }
    }

    /**
     * Creates an entity from a PipelineGraph protobuf message.
     * <p>
     * Serializes the PipelineGraph to JSON for storage in the graph_data JSONB column.
     *
     * @param graph The PipelineGraph protobuf to store
     * @return A new entity instance ready for persistence
     * @throws RuntimeException if JSON serialization fails
     */
    public static PipelineGraphEntity fromProto(PipelineGraph graph) {
        try {
            PipelineGraphEntity entity = new PipelineGraphEntity();
            entity.graphId = graph.getGraphId();
            entity.clusterId = graph.getClusterId();
            entity.version = graph.getVersion();
            entity.isActive = false; // Default to inactive, caller should set explicitly
            entity.createdAt = Instant.now();
            
            // Serialize PipelineGraph to JSON
            entity.graphData = JsonFormat.printer().print(graph);
            
            // Extract account_id from graph if available (might be in metadata)
            // For now, we'll require it to be set separately or included in the graph
            // This can be enhanced based on how account_id is stored in the proto
            
            return entity;
        } catch (InvalidProtocolBufferException e) {
            LOG.errorf(e, "Failed to serialize PipelineGraph to JSON for graph_id=%s", graph.getGraphId());
            throw new RuntimeException("Failed to serialize PipelineGraph", e);
        }
    }

    /**
     * Creates an entity from a PipelineGraph protobuf message with additional metadata.
     *
     * @param graph The PipelineGraph protobuf to store
     * @param accountId The account identifier for multi-tenant isolation
     * @param createdBy The user/service that created this version
     * @param isActive Whether this version should be marked as active
     * @return A new entity instance ready for persistence
     */
    public static PipelineGraphEntity fromProto(PipelineGraph graph, String accountId, String createdBy, boolean isActive) {
        PipelineGraphEntity entity = fromProto(graph);
        entity.accountId = accountId;
        entity.createdBy = createdBy;
        entity.isActive = isActive;
        return entity;
    }
}


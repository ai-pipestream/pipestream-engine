package ai.pipestream.engine.graph;

import ai.pipestream.engine.v1.DatasourceInstance;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.util.JsonFormat;
import io.quarkus.hibernate.reactive.panache.PanacheEntityBase;
import jakarta.persistence.*;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;
import org.jboss.logging.Logger;

import java.time.Instant;
import java.util.UUID;

/**
 * Entity representing a DatasourceInstance stored in PostgreSQL.
 * <p>
 * DatasourceInstances bind datasources (from datasource-admin) to entry nodes
 * in a pipeline graph. They contain Tier 2 (graph-level) configuration that
 * overrides Tier 1 (service-level) configuration from datasource-admin.
 * <p>
 * Key concepts:
 * <ul>
 *   <li>Each instance is tied to a specific graph version</li>
 *   <li>One datasource can have instances in multiple graphs (multicast)</li>
 *   <li>When a graph is activated, its instances are loaded into GraphCache</li>
 *   <li>IntakeHandoff uses instances to route documents to entry nodes</li>
 * </ul>
 *
 * @see ai.pipestream.engine.v1.DatasourceInstance
 */
@Entity
@Table(name = "datasource_instances", uniqueConstraints = {
    @UniqueConstraint(name = "uk_datasource_instance_id", columnNames = {"datasource_instance_id"}),
    @UniqueConstraint(name = "uk_graph_datasource", columnNames = {"graph_id", "version", "datasource_id"})
}, indexes = {
    @Index(name = "idx_datasource_instances_graph", columnList = "graph_id, version"),
    @Index(name = "idx_datasource_instances_datasource", columnList = "datasource_id"),
    @Index(name = "idx_datasource_instances_entry_node", columnList = "entry_node_id")
})
public class DatasourceInstanceEntity extends PanacheEntityBase {

    private static final Logger LOG = Logger.getLogger(DatasourceInstanceEntity.class);

    /** Primary key - UUID generated by database. */
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", updatable = false, nullable = false)
    public UUID id;

    /**
     * Unique instance ID in format: {graph_id}:{version}:{datasource_id}
     * <p>
     * This format ensures uniqueness across all graphs and versions,
     * and enables efficient lookup and graph-based unregistration.
     */
    @Column(name = "datasource_instance_id", nullable = false, length = 512, unique = true)
    public String datasourceInstanceId;

    /** Logical graph identifier this instance belongs to. */
    @Column(name = "graph_id", nullable = false, length = 255)
    public String graphId;

    /** Graph version this instance is associated with. */
    @Column(name = "version", nullable = false)
    public Long version;

    /** References datasource from datasource-admin (Tier 1 config owner). */
    @Column(name = "datasource_id", nullable = false, length = 255)
    public String datasourceId;

    /** Entry node ID where documents from this datasource enter the pipeline. */
    @Column(name = "entry_node_id", nullable = false, length = 255)
    public String entryNodeId;

    /**
     * Tier 2 NodeConfig stored as JSON.
     * <p>
     * Contains optional overrides of Tier 1 config:
     * - persistence_config
     * - retention_config
     * - hydration_config
     * - output_hints
     * - custom_config
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "node_config_json", columnDefinition = "jsonb")
    public String nodeConfigJson;

    /** Timestamp when this instance was created. */
    @Column(name = "created_at", nullable = false)
    public Instant createdAt;

    /** Timestamp when this instance was last updated. */
    @Column(name = "updated_at")
    public Instant updatedAt;

    /** User or service that created this instance. */
    @Column(name = "created_by", length = 255)
    public String createdBy;

    /**
     * Generates a datasource_instance_id from graph and datasource info.
     *
     * @param graphId Graph identifier
     * @param version Graph version
     * @param datasourceId Datasource identifier
     * @return Unique instance ID in format: {graph_id}:{version}:{datasource_id}
     */
    public static String generateInstanceId(String graphId, long version, String datasourceId) {
        return graphId + ":" + version + ":" + datasourceId;
    }

    /**
     * Converts this entity to a DatasourceInstance protobuf message.
     *
     * @return The DatasourceInstance proto
     */
    public DatasourceInstance toProto() {
        DatasourceInstance.Builder builder = DatasourceInstance.newBuilder()
            .setDatasourceInstanceId(datasourceInstanceId)
            .setDatasourceId(datasourceId)
            .setEntryNodeId(entryNodeId);

        // Parse node_config from JSON if present
        if (nodeConfigJson != null && !nodeConfigJson.isBlank()) {
            try {
                DatasourceInstance.NodeConfig.Builder nodeConfigBuilder = DatasourceInstance.NodeConfig.newBuilder();
                JsonFormat.parser().merge(nodeConfigJson, nodeConfigBuilder);
                builder.setNodeConfig(nodeConfigBuilder.build());
            } catch (InvalidProtocolBufferException e) {
                LOG.warnf(e, "Failed to parse NodeConfig JSON for instance %s, returning without node_config",
                    datasourceInstanceId);
            }
        }

        return builder.build();
    }

    /**
     * Creates an entity from request parameters.
     *
     * @param graphId Graph identifier
     * @param version Graph version
     * @param datasourceId Datasource identifier
     * @param entryNodeId Entry node ID
     * @param nodeConfig Optional Tier 2 configuration (can be null)
     * @param createdBy User/service creating this instance
     * @return A new entity instance ready for persistence
     */
    public static DatasourceInstanceEntity create(
            String graphId,
            long version,
            String datasourceId,
            String entryNodeId,
            DatasourceInstance.NodeConfig nodeConfig,
            String createdBy) {

        DatasourceInstanceEntity entity = new DatasourceInstanceEntity();
        entity.datasourceInstanceId = generateInstanceId(graphId, version, datasourceId);
        entity.graphId = graphId;
        entity.version = version;
        entity.datasourceId = datasourceId;
        entity.entryNodeId = entryNodeId;
        entity.createdAt = Instant.now();
        entity.createdBy = createdBy;

        // Serialize node_config to JSON if provided
        if (nodeConfig != null && nodeConfig != DatasourceInstance.NodeConfig.getDefaultInstance()) {
            try {
                entity.nodeConfigJson = JsonFormat.printer().print(nodeConfig);
            } catch (InvalidProtocolBufferException e) {
                LOG.warnf(e, "Failed to serialize NodeConfig to JSON, storing without node_config");
            }
        }

        return entity;
    }

    /**
     * Updates the node_config from a proto message.
     *
     * @param nodeConfig The new Tier 2 configuration
     */
    public void updateNodeConfig(DatasourceInstance.NodeConfig nodeConfig) {
        if (nodeConfig == null || nodeConfig == DatasourceInstance.NodeConfig.getDefaultInstance()) {
            this.nodeConfigJson = null;
        } else {
            try {
                this.nodeConfigJson = JsonFormat.printer().print(nodeConfig);
            } catch (InvalidProtocolBufferException e) {
                LOG.warnf(e, "Failed to serialize NodeConfig to JSON for update");
            }
        }
        this.updatedAt = Instant.now();
    }
}
